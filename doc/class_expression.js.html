<!doctype html>
<html>

<head>
  <meta name="generator" content="JSDoc 3.3.0">
  <meta charset="utf-8">
  <title>Source: class_expression.js</title>
  <link rel="stylesheet" href="https://brick.a.ssl.fastly.net/Karla:400,400i,700,700i" type="text/css">
  <link rel="stylesheet" href="https://brick.a.ssl.fastly.net/Noto+Serif:400,400i,700,700i" type="text/css">
  <link rel="stylesheet" href="https://brick.a.ssl.fastly.net/Inconsolata:500" type="text/css">
  <link href="css/baseline.css" rel="stylesheet">
</head>

<body onload="prettyPrint()">
  <nav id="jsdoc-navbar" role="navigation" class="jsdoc-navbar">
    <div id="jsdoc-navbar-container">
      <div id="jsdoc-navbar-content">
        <a href="index.html" class="jsdoc-navbar-package-name">Home</a>
      </div>
    </div>
  </nav>
  <div id="jsdoc-body-container">
    <div id="jsdoc-content">
      <div id="jsdoc-content-container">
        <div id="jsdoc-banner" role="banner">
        </div>
        <div id="jsdoc-main" role="main">
          <header class="page-header">
            <h1>Source: class_expression.js</h1>
          </header>
          <article>
            <pre class="prettyprint linenums"><code>/** 
 * Class expressions.
 * 
 * A handling library for OWL-style class expressions in JavaScript.
 * 
 * The idea here is to have a generic class expression class that can
 * be used at all levels of communication an display (instead of the
 * previous major/minor models).
 *
 * This is a full-bodied implementation of all the different aspects
 * that we need to capture for type class expressions: information
 * capture from JSON, on-the-fly creations, and display
 * properties. These used to be separate behaviors, but with the
 * client taking over more responsibility from Minerva, a more robust
 * and testable soluton was needed.
 * 
 * Types can be: class ids and the expressions: SVF, union, and
 * intersection. Of the latter group, all are nestable.
 * 
 * Categories is a graphical/UI distinction. They can be: instance_of,
 * &amp;lt;relation id&gt;, union, and intersection.
 * 
 * @module class-expression
 */

var us = require(&#x27;underscore&#x27;);
var each = us.each;
var keys = us.keys;
var bbop = require(&#x27;bbop-core&#x27;);
var what_is = bbop.what_is;

/**
 * Core constructor.
 *
 * The argument &quot;in_type&quot; may be:
 *  - a class id (string)
 *  - a JSON blob as described from Minerva
 *  - another &amp;lt;class_expression&gt;
 *  - null (user will load or interactively create one)
 *
 * @constructor
 * @param {String|Object|class_expression|null} - the raw type description (see above)
 */
class_expression = function(in_type){
    this._is_a = &#x27;class_expression&#x27;;

    var anchor = this;

    ///
    /// Initialize.
    ///

    // in_type is always a JSON object, trivial catch of attempt to
    // use just a string as a class identifier.
    if( in_type ){
    	if( what_is(in_type) == &#x27;class_expression&#x27; ){
    	    // Unfold and re-parse (takes some properties of new
    	    // host).
    	    in_type = in_type.structure();
    	}else if( what_is(in_type) == &#x27;object&#x27; ){
	    // Fine as it is.
    	}else if( what_is(in_type) == &#x27;string&#x27; ){
	    // Convert to a safe representation.
	    in_type = {
		&#x27;type&#x27;: &#x27;class&#x27;,
		&#x27;id&#x27;: in_type,
		&#x27;label&#x27;: in_type
	    };
    	}
    }

    // Every single one is a precious snowflake (which is necessary
    // for managing some of the aspects of the UI for some use cases).
    this._id = bbop.uuid();

    // Derived property defaults.
    this._type = null;
    this._category = &#x27;unknown&#x27;;
    this._class_id = null;
    this._class_label = null;
    this._property_id = null;
    this._property_label = null;
    // Recursive elements.
    this._frame = [];

    // 
    this._raw_type = in_type;
    if( in_type ){
	anchor.parse(in_type);
    }
};

/**
 * Get the unique ID of this class expression.
 * 
 * @returns {String} string
 */
class_expression.prototype.id = function(){
    return this._id;
};

/** 
 * If the type has a recursive frame.
 *
 * @returns {Boolean} true or false
 */
class_expression.prototype.nested_p = function(){
    var retval = false;
    if( this._frame.length &gt; 0 ){
	retval = true;
    }
    return retval;
};

/**
 * A cheap way of identifying if two class_expressions are the same.
 * This essentially returns a string of the main attributes of a type.
 * It is meant to be semi-unique and collide with dupe inferences.
 *
 * BUG/WARNING: At this point, colliding signatures should mean a
 * dupe, but non-colliding signatures does *not* guarantee that they
 * are not dupes (think different intersection orderings).
 *
 * @returns {String} string
 */
class_expression.prototype.signature = function(){
    var anchor = this;

    var sig = [];

    // The easy ones.
    sig.push(anchor.category() || &#x27;&#x27;);
    sig.push(anchor.type() || &#x27;&#x27;);
    sig.push(anchor.class_id() || &#x27;&#x27;);
    sig.push(anchor.property_id() || &#x27;&#x27;);

    // And now recursively on frames.
    if( anchor.frame() ){
	each(anchor.frame(), function(f){
	    sig.push(f.signature() || &#x27;&#x27;);
	});
    }

    return sig.join(&#x27;_&#x27;);
};

/** 
 * Try to put an instance type into some kind of rendering category.
 *
 * @returns {String} string (default &#x27;unknown&#x27;)
 */
class_expression.prototype.category = function(){
    return this._category;
};

/** 
 * The &quot;type&quot; of the type.
 *
 * @returns {String|null} string or null
 */
class_expression.prototype.type = function(){
    return this._type;
};

/** 
 * The class expression when we are dealing with SVF.
 *
 * @returns {String|null} type or null
 */
class_expression.prototype.svf_class_expression = function(){
    var ret = null;
    if( this.type() == &#x27;svf&#x27; ){
	ret = this._frame[0];
    }    
    return ret; 
};

/** 
 * The class expression when we are dealing with a ComplementOf.
 *
 * @returns {String|null} type or null
 */
class_expression.prototype.complement_class_expression = function(){
    var ret = null;
    if( this.type() == &#x27;complement&#x27; ){
	ret = this._frame[0];
    }    
    return ret; 
};

/** 
 * If the type has a recursive frame, a list of the cls expr it
 * contains.
 *
 * @returns {Array} list of {class_expression}
 */
class_expression.prototype.frame = function(){
    return this._frame;
};

/** 
 * The considered class id.
 *
 * @returns {String|null} string or null
 */
class_expression.prototype.class_id = function(){
    return this._class_id;
};

/** 
 * The considered class label, defaults to ID if not found.
 *
 * @returns {String|null} string or null
 */
class_expression.prototype.class_label = function(){
    return this._class_label;
};

/** 
 * The considered class property id.
 * Not defined for &#x27;class&#x27; types.
 *
 * @returns {String|null} string or null
 */
class_expression.prototype.property_id = function(){
    return this._property_id;
};

/** 
 * The considered class property label.
 * Not defined for &#x27;class&#x27; types.
 *
 * @returns {String|null} string or null
 */
class_expression.prototype.property_label = function(){
    return this._property_label;
};

/**
 * Parse a JSON blob into the current instance, clobbering anything in
 * there, except id.
 *
 * @params {Object} in_type - conformant JSON object
 * @returns {this} self
 */
class_expression.prototype.parse = function(in_type){

    var anchor = this;

    // Helper.
    function _decide_type(type){
	var rettype = null;
 
	// Easiest case.
	var t = type[&#x27;type&#x27;] || null;
	if( t == &#x27;class&#x27; ){
	    rettype = &#x27;class&#x27;;
	}else if( t == &#x27;union&#x27; ){
	    rettype = &#x27;union&#x27;;
	}else if( t == &#x27;intersection&#x27; ){
	    rettype = &#x27;intersection&#x27;;
	}else if( t == &#x27;svf&#x27; ){
	    rettype = &#x27;svf&#x27;;
	}else if( t == &#x27;complement&#x27; ){
	    rettype = &#x27;complement&#x27;;
	}else{
	    // No idea...
	}

	return rettype;
    }

    // Define the category, and build up an instant picture of what we
    // need to know about the property.
    var t = _decide_type(in_type);
    if( t == &#x27;class&#x27; ){

	// Easiest to extract.
	this._type = t;
	this._category = &#x27;instance_of&#x27;;
	this._class_id = in_type[&#x27;id&#x27;];
	this._class_label = in_type[&#x27;label&#x27;] || this._class_id;
	// No related properties.
	
    }else if( t == &#x27;union&#x27; || t == &#x27;intersection&#x27; ){ // conjunctions

	// These are simply recursive.
	this._type = t;
	this._category = t;

	// Load stuff into the frame.
	this._frame = [];
	var f_set = in_type[&#x27;expressions&#x27;] || [];
	each(f_set, function(f_type){
	    anchor._frame.push(new class_expression(f_type));
	}); 
    }else if( t == &#x27;svf&#x27; ){ // SVF
	    
	// We&#x27;re then dealing with an SVF: a property plus a class
	// expression. We are expecting a &quot;restriction&quot;, although we
	// don&#x27;t really do anything with that information (maybe
	// later).
	this._type = t;
	// Extract the property information
	this._category = in_type[&#x27;property&#x27;][&#x27;id&#x27;];
	this._property_id = in_type[&#x27;property&#x27;][&#x27;id&#x27;];
	this._property_label =
	    in_type[&#x27;property&#x27;][&#x27;label&#x27;] || this._property_id;	    

	// Okay, let&#x27;s recur down the class expression. It should just
	// be one, but we&#x27;ll just reuse the frame. Access should be
	// though svf_class_expression().
	var f_type = in_type[&#x27;filler&#x27;];
	this._frame = [new class_expression(f_type)];
    }else if( t == &#x27;complement&#x27; ){ // ComplementOf
	    
	// We&#x27;re then dealing with a ComplementOf. Not too bad.
	this._type = t;
	this._category = t;

	// Okay, let&#x27;s recur down the class expression. It should just
	// be one, but we&#x27;ll just reuse the frame. Access should be
	// though complement_class_expression().
	var f2_type = in_type[&#x27;filler&#x27;];
	this._frame = [new class_expression(f2_type)];
    }else{
	// Should not be possible, so let&#x27;s stop it here.
	//console.log(&#x27;unknown type :&#x27;, in_type);
	throw new Error(&#x27;unknown type leaked in&#x27;);
    }

    return anchor;
};

/**
 * Parse a JSON blob into the current instance, clobbering anything in
 * there, except id.
 *
 * @params {String} in_type - string
 * @returns {this} self
 */
class_expression.prototype.as_class = function(in_type){

    if( in_type ){
	var ce = new class_expression(in_type);
	this.parse(ce.structure());
    }

    return this;
};

/** 
 * Convert a null class_expression into an arbitrary SVF.
 *
 * @params {String} property_id - string
 * @params {String|class_expression} class_expr - ID string (e.g. GO:0022008) or &amp;lt;class_expression&gt;
 * @returns {this} self
 */
class_expression.prototype.as_svf = function(property_id, class_expr){

    // Cheap our way into this--can be almost anything.
    var cxpr = new class_expression(class_expr);

    // Our list of values must be defined if we go this way.
    var expression = {
	&#x27;type&#x27;: &#x27;svf&#x27;,
	&#x27;property&#x27;: {
	    &#x27;type&#x27;: &quot;property&quot;,
	    &#x27;id&#x27;: property_id
	},
	&#x27;filler&#x27;: cxpr.structure()
    };

    this.parse(expression);

    return this;
};

/** 
 * Convert a null class_expression into an arbitrary complement.
 *
 * @params {String|class_expression} class_expr - ID string (e.g. GO:0022008) or &amp;lt;class_expression&gt;
 * @returns {this} self
 */
class_expression.prototype.as_complement = function(class_expr){

    // Cheap our way into this--can be almost anything.
    var cxpr = new class_expression(class_expr);

    // Our list of values must be defined if we go this way.
    var expression = {
	&#x27;type&#x27;: &#x27;complement&#x27;,
	&#x27;filler&#x27;: cxpr.structure()
    };

    this.parse(expression);

    return this;
};

/**
 * Convert a null class_expression into a set of class expressions.
 *
 * @params {String} set_type - &#x27;intersection&#x27; || &#x27;union&#x27;
 * @params {Array} set_list - list of ID strings of &amp;lt;class_expressions&gt;
 * @returns {this} self
 */
class_expression.prototype.as_set = function(
    set_type, set_list){

    // We do allow empties.
    if( ! set_list ){ set_list = []; }

    if( set_type == &#x27;union&#x27; || set_type == &#x27;intersection&#x27; ){

	// Work into a viable argument.
	var set = [];
	each(set_list, function(item){
	    var cexpr = new class_expression(item);
	    set.push(cexpr.structure());
	}); 

	// A little massaging is necessary to get it into the correct
	// format here.
	var fset = set_type;
	var parsable = {};
	parsable[&#x27;type&#x27;] = fset;
	parsable[&#x27;expressions&#x27;] = set;
	this.parse(parsable);
    }

    return this;
};

/** 
 * Hm. Essentially dump out the information contained within into a
 * JSON object that is appropriate for consumption my Minerva
 * requests.
 *
 * @returns {Object} JSON object
 */
class_expression.prototype.structure = function(){

    var anchor = this;

    // We&#x27;ll return this.
    var expression = {};
    
    // Extract type.
    var t = anchor.type(); 
    if( t == &#x27;class&#x27; ){ // trivial

	expression[&#x27;type&#x27;] = &#x27;class&#x27;;
	expression[&#x27;id&#x27;] = anchor.class_id();

    }else if( t == &#x27;svf&#x27; ){ // SVF
	
	// Easy part of SVF.
	expression[&#x27;type&#x27;] = &#x27;svf&#x27;;
	expression[&#x27;property&#x27;] = {
	    &#x27;type&#x27;: &#x27;property&#x27;,
	    &#x27;id&#x27;: anchor.property_id()
	};
	
	// Recur for someValuesFrom class expression.
	var svfce = anchor.svf_class_expression();
	var st = svfce.type();
	expression[&#x27;filler&#x27;] = svfce.structure();
	
    }else if( t == &#x27;complement&#x27; ){ // ComplementOf
	
	expression[&#x27;type&#x27;] = &#x27;complement&#x27;;
	
	// Recur for someValuesFrom class expression.
	var cce = anchor.complement_class_expression();
	var ct = cce.type();
	expression[&#x27;filler&#x27;] = cce.structure();
	
    }else if( t == &#x27;union&#x27; || t == &#x27;intersection&#x27; ){ // compositions
	
	// Recursively add all of the types in the frame.
	var ecache = [];
	var frame = anchor.frame();
	each(frame, function(ftype){
	    ecache.push(ftype.structure());
	});

	// Correct structure.
	expression[&#x27;type&#x27;] = t;
	expression[&#x27;expressions&#x27;] = ecache;
	
    }else{
	throw new Error(&#x27;unknown type in request processing: &#x27; + t);
    }
    
    return expression;
};

/** 
 * An attempt to have a simple attempt at a string representation for
 * a class expression.
 *
 * @param {String} front_str - (optional) start the output string with (default &#x27;&#x27;)
 * @param {String} back_str - (optional) end the output string with (default &#x27;&#x27;)
 * @returns {String} simple string rep
 */
class_expression.prototype.to_string = function(front_str, back_str){
    var anchor = this;

    function _inner_lbl(ce){
	var inner_lbl = &#x27;???&#x27;;

	var cetype = ce.type();
	if( cetype == &#x27;class&#x27; ){
	    inner_lbl = ce.class_label();
	}else if( cetype == &#x27;union&#x27; || cetype == &#x27;intersection&#x27; ){
	    var cef = ce.frame();
	    inner_lbl = cetype + &#x27;[&#x27; + cef.length + &#x27;]&#x27;;
	}else if( cetype == &#x27;complement&#x27; ){
	    inner_lbl = &#x27;[!]&#x27;;
	}else if( cetype == &#x27;svf&#x27; ){
	    inner_lbl = &#x27;[SVF]&#x27;;
	}else{
	    inner_lbl = &#x27;???&#x27;;
	}

	return inner_lbl;
    }

    var ret = &#x27;[???]&#x27;;
    
    var t = anchor.type();
    var f = anchor.frame();

    if( t == &#x27;class&#x27; ){
	ret = anchor.class_label();
    }else if( t == &#x27;union&#x27; || t == &#x27;intersection&#x27; ){
	ret = t + &#x27;[&#x27; + f.length + &#x27;]&#x27;;
    }else if( t == &#x27;complement&#x27; ){
	ret = &#x27;!&#x27; + 
	    //&#x27;[&#x27; + anchor.to_string(anchor.complement_class_expression()) + &#x27;]&#x27;;
	    &#x27;[&#x27; + _inner_lbl(anchor.complement_class_expression()) + &#x27;]&#x27;;
    }else if( t == &#x27;svf&#x27; ){
	// SVF a little harder.
	var ctype = anchor.category();

	// Probe it a bit.
	var ce = anchor.svf_class_expression();
	ret = ctype + &#x27;(&#x27; + _inner_lbl(ce) + &#x27;)&#x27;;
    }else{
	ret = &#x27;???&#x27;;
    }

    // A little special &quot;hi&quot; for inferred types, or something.
    if( front_str &amp;amp;&amp;amp; typeof(front_str) === &#x27;string&#x27; ){
	ret = front_str + ret;
    }
    if( back_str &amp;amp;&amp;amp; typeof(back_str) === &#x27;string&#x27; ){
	ret = ret + back_str;
    }

    return ret;    
};

///
/// &quot;Static&quot; functions in package.
///

/** 
 * &quot;Static&quot; function that creates an intersection from a list of
 * whatever.
 *
 * @param {Array} list - list of conformant whatever
 * @returns {class_expression} object
 */
class_expression.intersection = function(list){
    var ce = new class_expression();
    ce.as_set(&#x27;intersection&#x27;, list);
    return ce;
};

/** 
 * &quot;Static&quot; function that creates a union from a list of whatever.
 *
 * @param {Array} list - list of conformant whatever
 * @returns {class_expression} object
 */
class_expression.union = function(list){
    var ce = new class_expression();
    ce.as_set(&#x27;union&#x27;, list);
    return ce;
};

/** 
 * &quot;Static&quot; function that creates a SomeValueFrom from a property ID
 * and a class_expression (or string or whatever).
 *
 * @param {String} prop_id - ID
 * @param {class_expression|String} cls_expr - thing
 * @returns {class_expression} object
 */
class_expression.svf = function(prop_id, cls_expr){
    var ce = new class_expression();
    ce.as_svf(prop_id, cls_expr);
    return ce;
};

/** 
 * &quot;Static&quot; function that creates the complement of a given class
 * expression.
 *
 * @param {class_expression|String} cls_expr - thing
 * @returns {class_expression} object
 */
class_expression.complement = function(cls_expr){
    var ce = new class_expression();
    ce.as_complement(cls_expr);
    return ce;
};

/** 
 * &quot;Static&quot; function that creates a class_expression from a class ID.
 *
 * @param {String} id - string id
 * @returns {class_expression} object
 */
class_expression.cls = function(id){
    var ce = new class_expression();
    ce.as_class(id);
    return ce;
};

// Exportable body.
module.exports = class_expression;
</code></pre>
          </article>
        </div>
      </div>
      <nav id="jsdoc-toc-nav" role="navigation"></nav>
    </div>
  </div>
  <footer id="jsdoc-footer" class="jsdoc-footer">
    <div id="jsdoc-footer-container">
      <p>
        Generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc</a> 3.3.0 on June 19, 2015.
      </p>
    </div>
  </footer>
  <script src="scripts/jquery.min.js"></script>
  <script src="scripts/jquery.cookie.js"></script>
  <script src="scripts/tree.jquery.js"></script>
  <script src="scripts/prettify.js"></script>
  <script src="scripts/jsdoc-toc.js"></script>
  <script src="scripts/linenumber.js"></script>
  <script src="scripts/scrollanchor.js"></script>
</body>

</html>